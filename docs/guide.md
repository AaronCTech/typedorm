# Step by step guide

Working with relational data in dynamoDB can be painful, but it doesn't have to be. This guide will walk you through relational data modeling can be simplified using TypeDORM.

## Creating a table

**Table** in TypeDORM is different to entity (at least until there is a way to provision table resource from entity schema), unlike [TypeORM](https://github.com/typeorm/typeorm), and must be provisioned (most likely outside of TypeDORM lifecycle) and declared like this:

```Typescript
const myTable = new Table({
  name: 'my-table',
  partitionKey: 'PK',
  sortKey: 'SK',
  indexes: {
    GSI1: {
      type: INDEX_TYPE.GSI,
      partitionKey: 'GSI1PK',
      sortKey: 'GSI1SK',
    },
    LSI1: {
      type: INDEX_TYPE.LSI,
      sortKey: 'LSI1SK',
    },
  },
});
```

_Note_: _when working with Single table, you will only need one global table declaration per connection._

## Create a model

When working with TypeDORM, first thing you would want to do is to define a model, this will define all the properties and it's types.

For example, storing our `User` as model will look like this,

```Typescript
export class User {
  id: string;
  name: string;
  email: string;
  status: string
}

```

This is what we will need to use when creating new records in dynamoDB, but TypeDORM doesn't know how to organize this model in table, such as what indexes it uses, what the primary key is, etc. , for that we need to defined an entity for model. You really only need to define model as entity if that model needs to be stored in dynamoDB table, any application level models can be excluded.

## Create an entity

**Entity** is a class representation of a model. `@Entity` lets TypeDORM know how to parse/un-parse. Primary key and any indexes defined in here must be of what the class can accept.
For example, if table is using simple primary key and trying to define `@Entity` decorator with composite primary key, TypeDORM will reject the configuration. In the same way if any index declared on entity does is not known to above table configuration, TypeDORM will reject it,

Turning earlier model into Entity

```Typescript
@Entity({
  name: 'user', // name of the entity that will be added to each item as an attribute
  // primary key
  primaryKey: {
    partitionKey: 'USER#{{id}}',
    sortKey: 'USER#{{id}}',
  },
  indexes: {
    // specify GSI1 key - "GSI1" named global secondary index needs to exist in above table declaration
    GSI1: {
      partitionKey: 'USER#{{id}}',
      sortKey: 'USER#{{id}}#STATUS#{{status}}',
      type: INDEX_TYPE.GSI,
    },
  },
})
export class User {
  id: string;
  name: string;
  email: string;
  status: string
}
```

Now, TypeDORM knows about all indexes, keys and how it needs to be structured, but still doesn't know about attributes that will go with specified entities and where to get values for tokens like `{{status}}`. we will do that next.

## Adding attributes to Entity

To add attributes to entity, use `@Attribute` or other higher level annotations like `@AutoGeneratedAttribute`.

```Typescript
import {Table} from '@typedorm/common';

@Entity({
  name: 'user', // name of the entity that will be added to each item as an attribute
  // primary key
  primaryKey: {
    partitionKey: 'USER#{{id}}',
    sortKey: 'USER#{{id}}',
  },
  indexes: {
    // specify GSI1 key - "GSI1" named global secondary index needs to exist in above table declaration
    GSI1: {
      partitionKey: 'USER#{{id}}',
      sortKey: 'USER#{{id}}#STATUS#{{status}}',
      type: INDEX_TYPE.GSI,
    },
  },
})
export class User {
  id: string;

  @Attribute()
  name: string;

  @Attribute({
    unique: true
  })
  email: string;

  @Attribute()
  status: string

  updatedAt: string
}
```

This will tell TypeDORM that entity `User` has `id`, `name`, `email`, `status` and `updatedAt`. There is also a `unique: true` option provided to `email`, what this does is tells TypeDORM to always maintain uniqueness on `email`.

## Adding auto generated attribute

When working with databases, there is usually a need of creating some sort of unique identifiers, TypeDORM can do that for you. All you need to do is to annotate property with `@AutoGeneratedAttribute` then specify strategy and other options.

```Typescript
import {Attribute, Entity, AutoGeneratedAttribute} from '@typedorm/common';
import {AUTO_GENERATE_ATTRIBUTE_STRATEGY} from '@typedorm/common';

@Entity({
  name: 'user', // name of the entity that will be added to each item as an attribute
  // primary key
  primaryKey: {
    partitionKey: 'USER#{{id}}',
    sortKey: 'USER#{{id}}',
  },
  indexes: {
    // specify GSI1 key - "GSI1" named global secondary index needs to exist in above table declaration
    GSI1: {
      partitionKey: 'USER#{{id}}',
      sortKey: 'USER#{{id}}#STATUS#{{status}}',
      type: INDEX_TYPE.GSI,
    },
  },
})
export class User {
  @AutoGeneratedAttribute({
    strategy: AUTO_GENERATE_ATTRIBUTE_STRATEGY.UUID4,
  })
  id: string;

  @Attribute()
  name: string;

  @Attribute({
    unique: true
  })
  email: string;

  @Attribute()
  status: string

  @AutoGeneratedAttribute({
    strategy: AUTO_GENERATE_ATTRIBUTE_STRATEGY.EPOCH,
    autoUpdate: true
  })
  updatedAt: string
}
```

Now, `id` and `updatedAt` will be auto generated based on specified strategy.
Other than that, there is a `autoUpdate: true` on `updatedAt`, which just marks it to be auto updated whenever new write operation happens on record.

## Creating Connection

Now we have entity and it's attributes created, it's time to register them in an connection. This configuration will usually go at in the entrypoint file, if using `express`, that will be your `app.js`.

```Typescript
import 'reflect-metadata';
import {createConnection} from '@typedorm/core';
import {User} from './entities/user.entity'

createConnection({
  table: myGlobalTable,
  entities: [User], // list other entities as you go
});

// or specify a match pattern where entities are stored, like this

createConnection({
  table: myGlobalTable,
  entities: './entities/*.entity.ts',
});

```

## Creating a record

This is all the minimum configuration we need, now let's create a user record.

```Typescript
import {getEntityManager} from '@typedorm/core';
import {User} from './entities/user.entity'

const user = new User();
user.name = 'Loki';
user.status = 'active';
user.email = 'loki@asgard.com'

const entityManger = getEntityManager();
// when working with single connection, this will return a entityManger for connection `default`.
// if there are multiple connections, you can do
// getConnection('my-connection').getEntityManger()

// create user record
const response = await entityManger.create(org);

// response:
// {
//   id: 'some-auto-generated-uuid',
//   name: 'Loki',
//   status: 'active',
//   email: 'loki@asgard.com'
// }
```

_Note_: _To understand how TypeDORM handles these entities under see [this](./how-it-works.md)._
