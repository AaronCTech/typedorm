import {
  AttributeOptionsUniqueType,
  CompositePrimaryKey,
  DYNAMO_ATTRIBUTE_PREFIX,
  EntityTarget,
  PrimaryKey,
  SimplePrimaryKey,
  Table,
  IsPrimaryKey,
} from '@typedorm/common';
import {buildPrimaryKeySchema} from '../../helpers/build-primary-key-schema';
import {DynamoEntitySchemaPrimaryKey} from './entity-metadata';
import {
  BaseAttributeMetadataOptions,
  BaseAttributeMetadata,
} from './base-attribute-metadata';

export interface AttributeMetadataOptions extends BaseAttributeMetadataOptions {
  table: Table;
  entityClass: EntityTarget<any>;
  unique?: AttributeOptionsUniqueType;
}

export class AttributeMetadata extends BaseAttributeMetadata {
  readonly unique?: DynamoEntitySchemaPrimaryKey;

  constructor(private options: AttributeMetadataOptions) {
    super({name: options.name, type: options.type});
    const {unique} = options;

    if (unique) {
      this.unique = this.buildUniqueAttributesPrimaryKey();
    }
  }

  private buildUniqueAttributesPrimaryKey() {
    const {unique, table, name, type} = this.options;

    if (IsPrimaryKey(unique)) {
      return buildPrimaryKeySchema({
        table,
        primaryKey: unique,
        attributes: {
          [name]: type,
        },
      });
    } else {
      return this.autoGeneratedPrimaryKeySchema();
    }
  }

  private autoGeneratedPrimaryKeySchema() {
    const {entityClass, name, type, table} = this.options;
    const primaryKey = {} as PrimaryKey;

    const uniqueKeyValue = `${DYNAMO_ATTRIBUTE_PREFIX}_${entityClass.name.toUpperCase()}.${name.toUpperCase()}#{{${name}}}`;

    if (table.usesCompositeKey()) {
      (primaryKey as CompositePrimaryKey).partitionKey = uniqueKeyValue;
      (primaryKey as CompositePrimaryKey).sortKey = uniqueKeyValue;
    } else {
      (primaryKey as SimplePrimaryKey).partitionKey = uniqueKeyValue;
    }

    return buildPrimaryKeySchema({
      table,
      primaryKey,
      attributes: {
        [name]: type,
      },
    });
  }
}
