import {ConnectionOptions} from './connection-options';
import {
  DYNAMO_QUERY_ITEMS_IMPLICIT_LIMIT,
  EntityTarget,
} from '@typedorm/common';
import {EntityManager} from '../manager/entity-manager';
import {TransactionManager} from '../manager/transaction-manager';
import {AttributeMetadata} from '../metadata/attribute-metadata';
import {AutoGeneratedAttributeMetadata} from '../metadata/auto-generated-attribute-metadata';
import {
  DynamoEntitySchemaPrimaryKey,
  EntityMetadata,
} from '../metadata/entity-metadata';
import {Table} from '../../../common/table';
import {ConnectionMetadataBuilder} from './connection-metadata-builder';

export class Connection {
  readonly name: string;
  readonly table: Table;
  readonly entityManager: EntityManager;
  readonly transactionManger: TransactionManager;
  readonly defaultConfig: {queryItemsImplicitLimit: number};

  private _entityMetadatas: Map<string, EntityMetadata>;
  private isConnected: boolean;

  constructor(private options: ConnectionOptions) {
    const {table, name = 'default'} = options;
    this.table = table;
    this.name = name;
    this.entityManager = new EntityManager(this);
    this.transactionManger = new TransactionManager();
    this.defaultConfig = {
      queryItemsImplicitLimit:
        options.dynamoQueryItemsImplicitLimit ??
        DYNAMO_QUERY_ITEMS_IMPLICIT_LIMIT,
    };
    /**
     * This makes sure that we only ever build entity metadatas once per connection
     */
    this.isConnected = false;
  }

  connect() {
    if (this.isConnected) {
      throw new Error(
        `There is already an active connection, Connect should only be called once per application.`
      );
    }

    this._entityMetadatas = new Map(
      this.buildMetadatas().map(entityMeta => [
        entityMeta.target.name,
        entityMeta,
      ])
    );

    this.isConnected = true;
    return this;
  }

  get entityMetadatas() {
    return Array.from(this._entityMetadatas.values());
  }

  hasMetadata<Entity>(entityClass: EntityTarget<Entity>) {
    return !!this.getEntityByTarget(entityClass);
  }

  getAttributesForEntity<Entity>(entityClass: EntityTarget<Entity>) {
    return this._entityMetadatas.get(entityClass.name).attributes;
  }

  get globalTable() {
    return this.table;
  }

  /**
   * Returns any attributes marked as unique
   * If attribute used in a primary key is marked as unique, it is ignored, since all primary key are always unique
   * @param entityClass
   */
  getUniqueAttributesForEntity<Entity>(entityClass: EntityTarget<Entity>) {
    const entityMetadata = this.getEntityByTarget(entityClass);

    if (!entityMetadata) {
      throw new Error(
        `Could not get unique attributes for entity, every class to be used as entity must have @Entity decorator on it.`
      );
    }

    return this.getAttributesForEntity<Entity>(entityClass).filter(attr => {
      // only attributes that are not part of primary key should be included
      return (
        (attr as AttributeMetadata)?.unique &&
        !this.isUsedForPrimaryKey(entityMetadata.schema.primaryKey, attr.name)
      );
    });
  }

  getEntityByTarget<Entity>(entityClass: EntityTarget<Entity>) {
    const metadata = this._entityMetadatas.get(entityClass.name);
    if (!metadata) {
      throw new Error(
        `No such entity named "${entityClass.name}" is known to TypeDrm, make sure it is declared at the connection creation time.`
      );
    }
    return this._entityMetadatas.get(entityClass.name);
  }

  getAutoUpdateAttributes<Entity>(entityClass: EntityTarget<Entity>) {
    return this.getAttributesForEntity(entityClass).filter(
      attr => (attr as AutoGeneratedAttributeMetadata)?.autoUpdate
    ) as AutoGeneratedAttributeMetadata[];
  }

  isUsedForPrimaryKey(
    primaryKey: DynamoEntitySchemaPrimaryKey,
    attributeName: string
  ) {
    return Object.keys(primaryKey._interpolations).some(key => {
      const currInterpolation = primaryKey._interpolations[key];
      return currInterpolation.includes(attributeName);
    });
  }

  private buildMetadatas() {
    return new ConnectionMetadataBuilder(this).buildEntityMetadatas(
      this.options.entities
    );
  }
}
