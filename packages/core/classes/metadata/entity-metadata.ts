import {EntityTarget, INDEX_TYPE} from '@typedorm/common';
import {getInterpolatedKeys} from '../../helpers/get-interpolated-keys';
import {validateKey} from '../../helpers/validate-key';
import {Connection} from '../connection/connection';
import {
  EntityRawMetadataOptions,
  Indexes,
  PrimaryKey,
} from '../../../common/metadata-storage';
import {IndexOptions, Table} from '../../../common/table';
import {AttributeMetadata} from './attribute-metadata';
import {AutoGeneratedAttributeMetadata} from './auto-generated-attribute-metadata';
import {BaseMetadata} from './base-metadata';

export type DynamoEntitySchemaPrimaryKey = {
  [key: string]: any;
  _interpolations?: {[key: string]: string[]};
};
type DynamoEntitySchemaIndexes = {
  [key: string]: IndexOptions & {
    // auto generated
    _name?: string;
    // for LSI, only contains interpolations for sort key
    _interpolations?: {[key: string]: string[]};
    // entity transformer will inject additional attributes
    [key: string]: any;
  };
};

export interface DynamoEntitySchema {
  primaryKey: DynamoEntitySchemaPrimaryKey;
  indexes?: DynamoEntitySchemaIndexes;
}

export type AttributeMetadataType =
  | AttributeMetadata
  | AutoGeneratedAttributeMetadata;

export interface EntityMetadataOptions extends EntityRawMetadataOptions {
  connection: Connection;
  attributes: AttributeMetadataType[];
}

export class EntityMetadata extends BaseMetadata {
  readonly name: string;
  readonly table: Table;
  readonly target: EntityTarget<any>;
  readonly attributes: AttributeMetadataType[];
  readonly schema: DynamoEntitySchema;
  constructor({
    connection,
    table,
    name,
    target,
    primaryKey,
    indexes,
    attributes,
  }: EntityMetadataOptions) {
    super(connection);
    this.name = name;
    this.target = target;
    this.attributes = attributes;

    if (table) {
      // if no entity level table is defined fallback to global connection table
      this.table = table;
    } else {
      this.table = connection.table;
    }

    const attributesKeyTypePair = this.attributes.reduce((acc, attr) => {
      acc[attr.name] = attr.type;
      return acc;
    }, {} as {[key: string]: string});

    this.validatePrimaryKey(this.table, primaryKey, attributesKeyTypePair);

    this.schema = {
      primaryKey: this.buildPrimaryKeySchema({
        table: this.table,
        primaryKey,
        attributes: attributesKeyTypePair,
      }),
      indexes: this.buildIndexesSchema({
        table: this.table,
        indexes,
        attributes: attributesKeyTypePair,
      }),
    };
  }

  private validatePrimaryKey(
    table: Table,
    primaryKey: PrimaryKey,
    attributes: {[key: string]: string}
  ) {
    if (table.usesCompositeKey() && !primaryKey.sortKey) {
      throw new Error(
        `Table "${table.name}" uses composite key as a primary key, thus sort key on entity "${this.target.name}" is required`
      );
    }

    if (primaryKey.sortKey && !table.usesCompositeKey()) {
      throw new Error(
        `Table "${table.name}" does not use composite key, given sort key "${primaryKey.sortKey}" will be ignored.`
      );
    }

    if (primaryKey.partitionKey) {
      validateKey(primaryKey.partitionKey, attributes);
    }
    if (primaryKey.sortKey) {
      validateKey(primaryKey.sortKey, attributes);
    }
  }

  private buildPrimaryKeySchema({
    table,
    primaryKey,
    attributes,
  }: {
    table: Table;
    primaryKey: PrimaryKey;
    attributes: {[key: string]: string};
  }) {
    const partitionKeyInterpolations = getInterpolatedKeys(
      primaryKey.partitionKey,
      attributes
    );
    if (table.usesCompositeKey()) {
      const sortKeyInterpolations = getInterpolatedKeys(
        primaryKey.sortKey,
        attributes
      );
      return {
        [table.partitionKey]: primaryKey.partitionKey,
        [table.sortKey]: primaryKey.sortKey,
        _interpolations: {
          [table.partitionKey]: partitionKeyInterpolations,
          [table.sortKey]: sortKeyInterpolations,
        },
      };
    } else {
      return {
        [table.partitionKey]: primaryKey.partitionKey,
        _interpolations: {
          [table.partitionKey]: partitionKeyInterpolations,
        },
      };
    }
  }

  private buildIndexesSchema({
    table,
    indexes,
    attributes,
  }: {
    table: Table;
    indexes: Indexes;
    attributes: {[key: string]: string};
  }) {
    return Object.keys(indexes || []).reduce((acc, key) => {
      const tableIndexSignature = table.getIndexByKey(key);
      if (!tableIndexSignature) {
        throw new Error(
          `No matching index signature found for index "${key}" in table "${table.name}"`
        );
      }

      const currentIndex = indexes[key];

      // validates and gets and fill set indexes interpolations of sort key
      const sortKeyInterpolations = getInterpolatedKeys(
        currentIndex.sortKey,
        attributes
      );

      if (tableIndexSignature.type === INDEX_TYPE.LSI) {
        acc[key] = {
          [tableIndexSignature.sortKey]: indexes[key].sortKey,
          type: tableIndexSignature.type,
          _name: key,
          _interpolations: {
            [tableIndexSignature.sortKey]: sortKeyInterpolations,
          },
        };
        return acc;
      } else {
        // validates and gets and fill set indexes interpolations of partition key
        const partitionKeyInterpolations = getInterpolatedKeys(
          currentIndex.partitionKey,
          attributes
        );

        acc[key] = {
          [tableIndexSignature.partitionKey]: indexes[key].partitionKey,
          [tableIndexSignature.sortKey]: indexes[key].sortKey,
          type: tableIndexSignature.type,
          _name: key,
          // remove any duplicates from partition or sort keys
          _interpolations: {
            [tableIndexSignature.partitionKey]: partitionKeyInterpolations,
            [tableIndexSignature.sortKey]: sortKeyInterpolations,
          },
        };
        return acc;
      }
    }, {} as any);
  }
}
